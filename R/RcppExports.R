# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculate belief, disbelief, unknown, plausibility, plausibility ratio
#' @name belplauHFast
#' @param MACC Vector of masses e.g. x$m
#' @param W2 Description matrix e.g. x$tt
#' @param h Hypotheses to be tested, same format as x$tt
#' @param display_progress Whether to show progress bar
#' @return A matrix of \code{M} rows by 5 columns is returned, where \code{M} is the number of hypothesis tested: \itemize{
#'  \item Column 1: the degree of Belief \code{bel};
#'  \item Column 2: the degree of Disbellief (belief in favor of the contrary hypothesis) \code{disbel};
#'  \item Column 3: the degree of Epistemic uncertainty \code{unc};
#'  \item Column 4: the degree of Plausibility \code{plau};
#'  \item Column 5: the Plausibility ratio \code{rplau}.
#'    }
#' @examples 1
#' @export
NULL

belplauHFast <- function(MACC, W2, h, display_progress = FALSE) {
    .Call(`_dst_belplauHFast`, MACC, W2, h, display_progress)
}

#' Augment a binary matrix with closure elements.
#' @name closure
#' @param ttx A binary matrix.
#' @param computeJoin = true: to compute join closure. Default = TRUE.
#' @param display_progress = true: to show progress bar. Default = FALSE.
#' @return tty A binary matrix including the closure elements.
#' @examples
#' ttx <- matrix(c(0,1,1,1,1,0,1,1,1), nrow=3, byrow = TRUE)
#' tty <- closure(ttx, computeJoin = FALSE)
#' @export
NULL

closure <- function(ttx, computeJoin = TRUE, display_progress = FALSE) {
    .Call(`_dst_closure`, ttx, computeJoin, display_progress)
}

#' Augment a sparse binary matrix with closure elements
#' @name closureSparse
#' @param ttx A sparse binary matrix
#' @param computeJoin = true: to compute join closure. Default = TRUE
#' @param display_progress = true: to show progress bar. Default = FALSE
#' @return A sparse binary matrix including the closure elements
#' @export
NULL

closureSparse <- function(ttx, computeJoin = TRUE, display_progress = FALSE) {
    .Call(`_dst_closureSparse`, ttx, computeJoin, display_progress)
}

#' Comptue commonality values of a group of simple support functions on its closure elements
#' @name commSparse
#' @param x The non-trivial support of the mass function
#' @param x_c A sparse binary matrix of closure elements
#' @param a Mass assigned to the non-trivial support
#' @param display_progress = true: to show progress bar. Default = FALSE
#' @return A sparse binary matrix including the closure elements
#' @export
NULL

commSparse <- function(x, x_c, a, display_progress = FALSE) {
    .Call(`_dst_commSparse`, x, x_c, a, display_progress)
}

#' Comptue iota elements of a sparse binary matrix of closure elements
#' @name iotaSparse
#' @param tt A sparse matrix of closure elements
#' @param display_progress = true: to show progress bar. Default = FALSE
#' @return A sparse binary matrix of the iota elements
#' @export
NULL

iotaSparse <- function(tt, display_progress = FALSE) {
    .Call(`_dst_iotaSparse`, tt, display_progress)
}

#' superBcaFast is a C++ algorithm aimed to optimize the computation of multiple support functions defined on very large frames of discernment
#' @name superBcaFast
#' @export
NULL

superBcaFast <- function(x_input, y, a, y0 = 0L, flip = TRUE, tree_type = "single", dsa = FALSE) {
    .Call(`_dst_superBcaFast`, x_input, y, a, y0, flip, tree_type, dsa)
}

#' superBcaFastPlauSingleton is a C++ algorithm aimed to optimize the computation of multiple support functions defined on very large frames of discernment
#' @name superBcaFastPlauSingleton
#' @export
NULL

superBcaFastPlauSingleton <- function(x_input, y, a, y0 = 0L, flip = TRUE, tree_type = "single", dsa = FALSE) {
    .Call(`_dst_superBcaFastPlauSingleton`, x_input, y, a, y0, flip, tree_type, dsa)
}

#' TreeFast is an algorithm aimed to optimize the computation of multiple support functions defined on very large frames of discernment
#' @name treeFast
NULL

buildTreeFast <- function(tt, q, display_progress = FALSE, indices = NULL) {
    .Call(`_dst_buildTreeFast`, tt, q, display_progress, indices)
}

updateTreeFast <- function(tree_ptr, xx_vec, s_vec) {
    .Call(`_dst_updateTreeFast`, tree_ptr, xx_vec, s_vec)
}

supersetFast <- function(node_ptr, z_vec) {
    .Call(`_dst_supersetFast`, node_ptr, z_vec)
}

unravelTreeFast <- function(tree_ptr) {
    .Call(`_dst_unravelTreeFast`, tree_ptr)
}

inspectNode <- function(tree_ptr) {
    .Call(`_dst_inspectNode`, tree_ptr)
}

inspectNodes <- function(trees) {
    .Call(`_dst_inspectNodes`, trees)
}

buildTreesFast <- function(tt, q) {
    .Call(`_dst_buildTreesFast`, tt, q)
}

unravelTreesFast <- function(trees) {
    .Call(`_dst_unravelTreesFast`, trees)
}

updateTreesFast <- function(trees, xx_vec, s_vec) {
    .Call(`_dst_updateTreesFast`, trees, xx_vec, s_vec)
}

